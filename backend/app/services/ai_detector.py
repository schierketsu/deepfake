from typing import Dict, Any, List
import math

class AIDetector:
    """Эвристический детектор признаков ИИ-модификаций"""
    
    def __init__(self):
        self.ai_software_list = [
            "stable diffusion",
            "midjourney",
            "dall-e",
            "dalle",
            "dall·e",
            "comfyui",
            "comfy ui",
            "automatic1111",
            "automatic 1111",
            "novelai",
            "novel ai",
            "leonardo",
            "runway",
            "sora",
            "pika",
            "generated",
            "ai generated",
            "artificial intelligence",
            "ai art",
            "neural network",
            "deep learning",
            "gan",
            "vae",
            "diffusion",
            "latent diffusion",
            "openai",
            "open ai",
            "stability ai",
            "stabilityai",
            "dreamstudio",
            "dream studio",
            "lexica",
            "nightcafe",
            "night cafe",
            "artbreeder",
            "art breeder",
            "thispersondoesnotexist",
            "this person does not exist",
            "generated by",
            "created with ai",
            "ai tool",
            "machine learning"
        ]
    
    def detect_ai_signs(self, metadata: Dict[str, Any], file_type: str = "image") -> Dict[str, Any]:
        """
        Обнаружение признаков ИИ-вмешательства
        
        Args:
            metadata: Метаданные файла
            file_type: Тип файла ("image" или "video")
            
        Returns:
            Словарь с обнаруженными признаками и вероятностью
        """
        result = {
            "software_detected": [],
            "heuristics": {},
            "anomalies": [],
            "ai_probability": 0,
            "confidence": "low"
        }
        
        if file_type == "image":
            result = self._detect_image_ai_signs(metadata)
        elif file_type == "video":
            result = self._detect_video_ai_signs(metadata)
        
        # Сохраняем ссылку на metadata для использования в calculate_ai_probability
        result["_metadata_ref"] = metadata
        
        # Расчет итоговой вероятности
        result["ai_probability"] = self.calculate_ai_probability(result)
        result["confidence"] = self.generate_confidence_score(result, metadata)
        
        # Удаляем служебное поле перед возвратом
        result.pop("_metadata_ref", None)
        
        return result
    
    def _build_c2pa_evidence(self, metadata: Dict[str, Any]) -> List[str]:
        """
        Формирует список фактов из метаданных C2PA/Content Credentials.
        Основа для вывода «по фактам», без интерпретаций.
        """
        facts = []
        exif = metadata.get("exif", {}) or {}
        c2pa = exif.get("_c2pa_metadata") or {}
        manifest_types = exif.get("_c2pa_manifest_types") or []
        
        if not c2pa and not manifest_types:
            return facts
        
        # 1. C2PA / Content Credentials присутствуют
        if manifest_types:
            # Фильтруем и форматируем типы манифестов (убираем технические URI, оставляем только типы)
            clean_types = []
            for mt in manifest_types:
                mt_str = str(mt)
                # Извлекаем только тип (например, c2pa.created, c2pa.signature)
                if 'c2pa.' in mt_str:
                    # Берем только часть после последнего / или #, если это URI
                    if '/' in mt_str or '#' in mt_str:
                        parts = mt_str.replace('self#jumbf=', '').split('/')
                        for part in parts:
                            if part.startswith('c2pa.') and part not in clean_types:
                                clean_types.append(part.split('.')[1] if '.' in part else part)
                    else:
                        # Просто тип без URI
                        if mt_str.startswith('c2pa.'):
                            clean_types.append(mt_str.replace('c2pa.', ''))
                        elif mt_str not in clean_types:
                            clean_types.append(mt_str)
            
            # Убираем дубликаты и сортируем
            clean_types = sorted(list(set(clean_types)))[:10]  # Ограничиваем до 10 типов
            
            if clean_types:
                types_text = ", ".join(clean_types)
            else:
                # Если не удалось извлечь чистые типы, используем короткую версию
                types_text = "присутствуют"
            
            facts.append(
                "C2PA / Content Credentials присутствуют. "
                "В файле встроен JUMBF-манифест с типами: " + types_text + ". "
                "Это стандарт Content Authenticity Initiative — фиксация происхождения и истории генерации/обработки контента."
            )
        elif c2pa:
            facts.append(
                "C2PA / Content Credentials присутствуют. "
                "Стандарт Content Authenticity Initiative — фиксация происхождения и истории генерации/обработки контента."
            )
        
        # 2. Явно указан алгоритмический источник (ИИ)
        ds = c2pa.get("c2pa_digital_source_type") or ""
        ds_str = str(ds)
        if "trainedAlgorithmicMedia" in ds_str or "algorithmic" in ds_str.lower() or "digitalsourcetype" in ds_str.lower():
            facts.append(
                "Явно указано, что источник — алгоритмический. "
                "ActionsDigitalSourceType: " + ds_str + " — прямое указание: обученный алгоритм (ИИ)."
            )
        
        # 3. Указан софт-агент и генератор (поддержка разных ключей из ExifTool/CBOR)
        agent = (
            (c2pa.get("c2pa_software_agent") or c2pa.get("actions_software_agent_name") or "")
        ).strip()
        if isinstance(agent, (list, tuple)):
            agent = ", ".join(str(x) for x in agent) if agent else ""
        else:
            agent = str(agent).strip()
        generator = (
            (c2pa.get("c2pa_generator_name") or c2pa.get("claim_generator_info_name") or "")
        ).strip()
        if isinstance(generator, (list, tuple)):
            generator = ", ".join(str(x) for x in generator) if generator else ""
        else:
            generator = str(generator).strip()
        if agent or generator:
            parts = []
            if agent:
                parts.append("Actions Software Agent Name: " + agent)
            if generator:
                parts.append("Claim Generator Info Name: " + generator)
            facts.append(
                "Указан софт-агент генерации: " + " | ".join(parts) + ". "
                "Изображение создано или сконвертировано указанным агентом (например, ChatGPT, GPT-4o)."
            )
        
        # 4. Зафиксированы действия (c2pa.created, c2pa.converted и т.д.)
        actions = (c2pa.get("c2pa_actions") or "").strip()
        if actions:
            facts.append(
                "Зафиксированы действия: " + actions + ". "
                "Шаги создания/конвертации зафиксированы в цепочке доверия."
            )
        
        # 5. Подпись валидна
        validation = c2pa.get("c2pa_validation_success") or ""
        val_str = str(validation).lower()
        if "valid" in val_str or "success" in val_str or "claimSignature" in val_str:
            facts.append(
                "Подпись валидна. " + (str(validation) if validation else "ValidationResultsActiveManifestSuccessCode: данные проверены.") + " "
                "Манифест не поддельный и не повреждён — метаданные достоверны."
            )
        
        return facts
    
    def _detect_image_ai_signs(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Детекция ИИ-признаков: приоритет — факты из C2PA, затем эвристики."""
        result = {
            "software_detected": [],
            "heuristics": {},
            "anomalies": [],
            "evidence_from_metadata": []  # Факты из метаданных (C2PA и т.д.)
        }
        
        exif = metadata.get("exif", {}) or {}
        c2pa = exif.get("_c2pa_metadata") or {}
        has_c2pa = bool(c2pa or exif.get("_c2pa_manifest_types"))
        
        # 1. Сначала — факты из C2PA/Content Credentials
        evidence = self._build_c2pa_evidence(metadata)
        if evidence:
            result["evidence_from_metadata"] = evidence
            # Софт из C2PA
            if c2pa.get("c2pa_software_agent"):
                result["software_detected"].append("C2PA: " + str(c2pa["c2pa_software_agent"]))
            if c2pa.get("c2pa_generator_name"):
                name = str(c2pa["c2pa_generator_name"])
                if name and name not in [s.replace("C2PA: ", "") for s in result["software_detected"]]:
                    result["software_detected"].append("C2PA Generator: " + name)
        
        # Уже обнаруженный ИИ-софт из image_analyzer
        ai_software = metadata.get("ai_software_detected", [])
        for s in ai_software:
            if s not in result["software_detected"]:
                result["software_detected"].append(s)
        
        heuristics = {}
        
        # 2. Эвристики — только если нет сильных C2PA-фактов (чтобы не дублировать и не завышать по эвристике)
        integrity = metadata.get("metadata_integrity", {})
        image_chars = metadata.get("image_characteristics", {}) or {}
        supports_exif = image_chars.get("supports_exif", True)
        
        if not has_c2pa or not result["evidence_from_metadata"]:
            if integrity.get("metadata_removed"):
                heuristics["missing_metadata"] = True
                result["anomalies"].append("Метаданные удалены или отсутствуют")
            contradictions = integrity.get("contradictions", [])
            if contradictions:
                heuristics["metadata_contradictions"] = True
                result["anomalies"].extend(contradictions)
        
        if image_chars and (not has_c2pa or not result["evidence_from_metadata"]):
            if image_chars.get("is_square"):
                heuristics["square_image"] = True
                result["anomalies"].append("Квадратное изображение (типично для ИИ-генераторов)")
            if image_chars.get("is_standard_ai_size"):
                heuristics["standard_ai_size"] = True
                result["anomalies"].append("Стандартный размер для ИИ-генератора")
            if supports_exif:
                if not image_chars.get("has_gps"):
                    heuristics["no_gps"] = True
                if not image_chars.get("has_camera_info"):
                    heuristics["no_camera_info"] = True
                if not image_chars.get("has_shooting_params"):
                    heuristics["no_shooting_params"] = True
            for feature in image_chars.get("suspicious_features", []):
                if not any(feature.lower() in a.lower() or a.lower() in feature.lower() for a in result["anomalies"]):
                    result["anomalies"].append(feature)
        
        if exif and (not has_c2pa or not result["evidence_from_metadata"]):
            if "iso" in exif:
                try:
                    iso = int(str(exif["iso"]))
                    if iso < 50:
                        heuristics["unusual_iso"] = True
                        result["anomalies"].append(f"Необычно низкий ISO: {iso}")
                except (ValueError, TypeError):
                    pass
            if supports_exif and "date_time" not in exif:
                heuristics["no_datetime"] = True
                result["anomalies"].append("Отсутствует дата и время съемки")
        
        if image_chars and (not has_c2pa or not result["evidence_from_metadata"]):
            if not supports_exif:
                if image_chars.get("is_square") and image_chars.get("is_standard_ai_size"):
                    heuristics["multiple_ai_indicators"] = True
                    result["anomalies"].append("PNG с признаками ИИ-генерации (квадратное, стандартный размер)")
            else:
                missing_count = sum([
                    not image_chars.get("has_gps"),
                    not image_chars.get("has_camera_info"),
                    not image_chars.get("has_shooting_params")
                ])
                if missing_count >= 2:
                    fmt = (image_chars.get("file_format") or "изображения").upper()
                    if image_chars.get("is_square"):
                        heuristics["multiple_ai_indicators"] = True
                        result["anomalies"].append(f"Множественные признаки ИИ: квадратное {fmt} без метаданных")
                    elif missing_count == 3:
                        heuristics["multiple_ai_indicators"] = True
                        result["anomalies"].append("Полное отсутствие EXIF (GPS, камера, параметры съемки)" + (" — подозрительно для JPEG" if fmt in ("JPEG", "JPG") else ""))
        
        existing_lower = [a.lower() for a in result["anomalies"]]
        if supports_exif and (not has_c2pa or not result["evidence_from_metadata"]):
            if heuristics.get("no_gps") and not any("gps" in a or "координат" in a for a in existing_lower):
                result["anomalies"].append("Отсутствуют GPS координаты")
            if heuristics.get("no_camera_info") and not any("камера" in a for a in existing_lower):
                result["anomalies"].append("Отсутствует информация о камере")
            if heuristics.get("no_shooting_params") and not any("параметр" in a or "выдержка" in a for a in existing_lower):
                result["anomalies"].append("Отсутствуют параметры съемки (ISO, выдержка и т.д.)")
        
        seen = set()
        unique_anomalies = []
        for a in result["anomalies"]:
            al = a.lower()
            if not any((al in s or s in al) and len(al) > 10 for s in seen):
                unique_anomalies.append(a)
                seen.add(al)
        result["anomalies"] = unique_anomalies
        result["heuristics"] = heuristics
        return result
    
    def _detect_video_ai_signs(self, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Детекция ИИ-признаков в видео"""
        result = {
            "software_detected": [],
            "heuristics": {},
            "anomalies": []
        }
        
        # Проверка encoder string на признаки ИИ
        encoding_info = metadata.get("encoding_info", {})
        if encoding_info.get("ai_indicators"):
            result["software_detected"] = encoding_info["ai_indicators"]
        
        if encoding_info.get("suspicious"):
            result["anomalies"].append("Подозрительный encoder string")
        
        # Эвристики для видео
        heuristics = {}
        
        # 1. Аномалии кодирования
        anomalies = metadata.get("anomalies", [])
        if anomalies:
            result["anomalies"].extend(anomalies)
            heuristics["encoding_anomalies"] = True
        
        # 2. Несоответствия frame rate
        frame_consistency = metadata.get("frame_consistency", {})
        if not frame_consistency.get("frame_rate_consistent"):
            heuristics["frame_rate_inconsistency"] = True
            result["anomalies"].append("Несоответствие кадровой частоты")
        
        # 3. Необычная структура GOP
        if not frame_consistency.get("gop_structure_ok"):
            heuristics["gop_anomalies"] = True
        
        result["heuristics"] = heuristics
        
        return result

    def calculate_ai_probability(self, indicators: Dict[str, Any]) -> int:
        """
        Расчёт вероятности ИИ-вмешательства (0–100%).
        Приоритет: факты из C2PA/метаданных → эвристики.
        """
        evidence = indicators.get("evidence_from_metadata", [])
        software_detected = indicators.get("software_detected", [])
        
        # Факты из C2PA/Content Credentials — основа вывода, без интерпретаций
        if evidence:
            c2pa_software = any("C2PA" in str(s) for s in software_detected)
            if c2pa_software or any("алгоритм" in e.lower() or "algorithmic" in e.lower() or "agent" in e.lower() for e in evidence):
                return min(100, 95 + (5 if len(evidence) >= 3 else 0))  # 95–100%
            return 90  # C2PA есть, но без явного указания ИИ — всё равно высоко
        
        # Эвристики — когда нет C2PA-фактов
        probability = 0
        if software_detected:
            probability += 70
        metadata_ref = indicators.get("_metadata_ref", {})
        image_chars = metadata_ref.get("image_characteristics", {})
        supports_exif = image_chars.get("supports_exif", True)
        heuristics = indicators.get("heuristics", {})
        
        # Проверяем, есть ли сильные признаки помимо отсутствия метаданных
        has_strong_indicators = (
            heuristics.get("square_image") or 
            heuristics.get("standard_ai_size") or
            heuristics.get("metadata_contradictions")
        )
        
        # Если multiple_ai_indicators основан только на отсутствии метаданных (без других признаков),
        # снижаем его вес и не суммируем отдельные "отсутствие X"
        multiple_from_missing_only = (
            heuristics.get("multiple_ai_indicators") and 
            not has_strong_indicators
        )
        
        heuristic_weights = {
            # Сильные индикаторы (высокий вес)
            "standard_ai_size": 25,
            "square_image": 20,
            "metadata_contradictions": 25,
            
            # multiple_ai_indicators: высокий вес только если есть другие признаки
            "multiple_ai_indicators": 30 if has_strong_indicators else 20,
            
            # Отсутствие метаданных: средний вес, но не суммируем если уже учтено в multiple_ai_indicators
            "missing_metadata": 15 if supports_exif and not multiple_from_missing_only else 0,
            
            # Отдельные "отсутствие X": не суммируем если уже учтено в multiple_ai_indicators
            "no_gps": 10 if supports_exif and not multiple_from_missing_only else 0,
            "no_camera_info": 10 if supports_exif and not multiple_from_missing_only else 0,
            "no_shooting_params": 10 if supports_exif and not multiple_from_missing_only else 0,
            "no_datetime": 8 if supports_exif else 0,
            
            # Другие индикаторы
            "unusual_iso": 10,
            "encoding_anomalies": 15,
            "frame_rate_inconsistency": 10,
            "gop_anomalies": 10,
        }
        
        for h, w in heuristic_weights.items():
            if heuristics.get(h) and w > 0:
                probability += w
        
        # Аномалии добавляют вероятность, но с ограничением для случая "только отсутствие метаданных"
        anomaly_count = len(indicators.get("anomalies", []))
        if multiple_from_missing_only:
            # Если только отсутствие метаданных, ограничиваем бонус от аномалий
            if anomaly_count >= 3:
                probability += 10
            elif anomaly_count >= 2:
                probability += 5
        else:
            # Обычный бонус от аномалий
            if anomaly_count >= 5:
                probability += 25
            elif anomaly_count >= 3:
                probability += 15
            elif anomaly_count >= 2:
                probability += 8
            elif anomaly_count >= 1:
                probability += 3
        
        # Бонус за комбинацию сильных признаков
        if supports_exif and heuristics.get("square_image") and heuristics.get("no_gps") and heuristics.get("no_camera_info"):
            probability += 10
        
        # Минимальная вероятность для изображений без метаданных (только для JPEG)
        if supports_exif and heuristics.get("missing_metadata") and anomaly_count >= 2 and not has_strong_indicators:
            probability = max(probability, 25)  # Снижено с 30 до 25
        
        # Ограничение: если только отсутствие метаданных без других признаков, максимум 50%
        if multiple_from_missing_only and not has_strong_indicators and not software_detected:
            probability = min(probability, 50)
        
        # Без явных доказательств (C2PA, софт в метаданных) — только эвристики: не выше 45%
        if not evidence and not software_detected:
            probability = min(probability, 45)
        
        return min(probability, 100)
    
    def generate_confidence_score(
        self,
        indicators: Dict[str, Any],
        metadata: Dict[str, Any]
    ) -> str:
        """
        Оценка достоверности анализа.
        Высокая — по фактам из C2PA/метаданных; средняя — по эвристикам; низкая — мало данных.
        """
        # Высокая: факты из метаданных (C2PA, подпись, источник)
        if indicators.get("evidence_from_metadata"):
            return "high"
        if indicators.get("software_detected"):
            return "high"
        heuristics = indicators.get("heuristics", {})
        anomalies = indicators.get("anomalies", [])
        if heuristics or len(anomalies) > 1:
            return "medium"
        return "low"
    
    def analyze_image_characteristics(
        self, 
        image_path: str, 
        metadata: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Анализ характеристик изображения (качество, шум, симметрия)
        
        Примечание: Это требует дополнительных библиотек для анализа изображений
        (например, OpenCV, scikit-image). Пока возвращаем базовую структуру.
        """
        characteristics = {
            "quality_score": None,
            "noise_level": None,
            "symmetry_score": None,
            "suspicious_patterns": []
        }
        
        # TODO: Реализовать анализ изображения с помощью OpenCV/scikit-image
        # - Анализ шума (AI-изображения часто имеют характерный шум)
        # - Проверка симметрии (AI часто создает слишком симметричные изображения)
        # - Анализ артефактов генерации
        
        return characteristics
