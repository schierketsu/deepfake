import exifread
from PIL import Image
from PIL.ExifTags import TAGS, GPSTAGS
import piexif
from typing import Dict, Any, Optional, List
import os
import subprocess
import json
import platform
import logging
import shutil

logger = logging.getLogger(__name__)

class ImageAnalyzer:
    """Анализатор метаданных изображений"""
    
    # Кэш для результатов проверки ExifTool (чтобы не проверять каждый раз)
    _exiftool_available: Optional[bool] = None
    _exiftool_command: Optional[str] = None
    
    def __init__(self):
        self.ai_software_keywords = [
            "stable diffusion",
            "midjourney",
            "dall-e",
            "dalle",
            "dall·e",
            "comfyui",
            "comfy ui",
            "automatic1111",
            "automatic 1111",
            "novelai",
            "novel ai",
            "leonardo",
            "runway",
            "sora",
            "pika",
            "generated",
            "ai generated",
            "artificial intelligence",
            "ai art",
            "neural network",
            "deep learning",
            "gan",
            "vae",
            "diffusion",
            "latent diffusion",
            "openai",
            "open ai",
            "stability ai",
            "stabilityai",
            "dreamstudio",
            "dream studio",
            "lexica",
            "nightcafe",
            "night cafe",
            "artbreeder",
            "art breeder",
            "thispersondoesnotexist",
            "this person does not exist",
            "generated by",
            "created with ai",
            "ai tool",
            "machine learning"
        ]
    
    def analyze(self, file_path: str) -> Dict[str, Any]:
        """
        Полный анализ метаданных изображения
        
        Args:
            file_path: Путь к файлу изображения
            
        Returns:
            Словарь с метаданными и результатами анализа
        """
        result = {
            "exif": {},
            "xmp": {},
            "image_characteristics": {},
            "metadata_integrity": {
                "has_exif": False,
                "has_xmp": False,
                "metadata_removed": False,
                "contradictions": []
            },
            "ai_software_detected": []
        }
        
        # Извлечение EXIF данных
        exif_data = self.extract_exif_data(file_path)
        result["exif"] = exif_data
        
        # Извлечение XMP данных
        xmp_data = self.extract_xmp_data(file_path)
        result["xmp"] = xmp_data
        
        # Анализ характеристик изображения
        image_chars = self.analyze_image_characteristics(file_path, exif_data)
        result["image_characteristics"] = image_chars
        
        # Проверка целостности метаданных
        integrity = self.check_metadata_integrity(exif_data, xmp_data, image_chars)
        result["metadata_integrity"] = integrity
        
        # Поиск упоминаний ИИ-инструментов
        ai_software = self.detect_ai_software(exif_data, xmp_data)
        result["ai_software_detected"] = ai_software
        
        return result
    
    def _get_exiftool_paths(self) -> List[str]:
        """Получение возможных путей к exiftool"""
        paths = []
        
        # Стандартные команды (если в PATH)
        if platform.system() == 'Windows':
            paths.extend(['exiftool.exe', 'exiftool'])
        else:
            paths.append('exiftool')
        
        # Локальный путь в проекте
        # Получаем корень проекта (на 3 уровня выше от backend/app/services/image_analyzer.py)
        current_file = os.path.abspath(__file__)
        backend_dir = os.path.dirname(os.path.dirname(os.path.dirname(current_file)))
        project_root = os.path.dirname(backend_dir)
        
        # Возможные пути к exiftool в проекте
        local_paths = [
            os.path.join(project_root, 'exiftool-13.48_64', 'exiftool(-k).exe'),
            os.path.join(project_root, 'exiftool-13.48_64', 'exiftool.exe'),
            os.path.join(project_root, 'exiftool-13.48_64', 'exiftool'),
            os.path.join(project_root, 'exiftool', 'exiftool.exe'),
            os.path.join(project_root, 'exiftool', 'exiftool'),
        ]
        
        # Также проверяем альтернативные варианты путей
        # Иногда путь может быть определен относительно текущей директории
        try:
            current_dir = os.getcwd()
            alt_paths = [
                os.path.join(current_dir, 'exiftool-13.48_64', 'exiftool(-k).exe'),
                os.path.join(current_dir, 'exiftool-13.48_64', 'exiftool.exe'),
            ]
            local_paths.extend(alt_paths)
        except:
            pass
        
        # Проверяем существование файлов перед добавлением
        for path in local_paths:
            abs_path = os.path.abspath(path)
            if os.path.exists(abs_path):
                logger.debug(f"Найден локальный ExifTool: {abs_path}")
                paths.append(abs_path)
                
                # Для файла со скобками также пробуем создать временную копию без скобок
                if '(' in abs_path and ')' in abs_path and platform.system() == 'Windows':
                    try:
                        # Создаем временную копию без скобок в той же директории
                        exiftool_dir = os.path.dirname(abs_path)
                        temp_exiftool = os.path.join(exiftool_dir, 'exiftool_temp.exe')
                        if not os.path.exists(temp_exiftool):
                            import shutil
                            shutil.copy2(abs_path, temp_exiftool)
                            logger.info(f"Создана временная копия ExifTool без скобок: {temp_exiftool}")
                        if os.path.exists(temp_exiftool):
                            paths.append(temp_exiftool)
                    except Exception as e:
                        logger.debug(f"Не удалось создать временную копию: {e}")
            else:
                logger.debug(f"Локальный путь не существует: {abs_path}")
        
        return paths
    
    def _check_exiftool_available(self) -> bool:
        """Проверка доступности exiftool (с кэшированием результата)"""
        logger.info("Проверка доступности ExifTool...")
        # Используем кэшированный результат, если он есть
        if ImageAnalyzer._exiftool_available is not None:
            logger.info(f"Использование кэшированного результата: ExifTool {'доступен' if ImageAnalyzer._exiftool_available else 'недоступен'}")
            return ImageAnalyzer._exiftool_available
        
        logger.info("Кэш пуст, начинаю проверку путей...")
        paths = self._get_exiftool_paths()
        logger.info(f"Проверка доступности ExifTool. Пути для проверки ({len(paths)}): {paths[:3]}...")  # Показываем первые 3 пути
        
        for i, path in enumerate(paths, 1):
            logger.info(f"Проверка пути {i}/{len(paths)}: {path}")
            try:
                # Для Windows проверяем существование файла
                if platform.system() == 'Windows':
                    # Для путей без расширения (команды в PATH) пропускаем проверку существования
                    if not path.endswith('.exe') and not os.path.exists(path):
                        # Это может быть команда в PATH, пробуем запустить
                        logger.debug(f"Путь без расширения, пробуем запустить: {path}")
                        pass
                    elif not os.path.exists(path):
                        logger.debug(f"Путь не существует: {path}")
                        continue
                    else:
                        logger.debug(f"Путь существует: {path}")
                
                # Для Windows с файлами, содержащими скобки, используем прямой запуск из директории
                if platform.system() == 'Windows' and '(' in path and ')' in path:
                    logger.info(f"Запуск файла со скобками: {path}")
                    # Проверяем существование файла перед запуском
                    if not os.path.exists(path):
                        logger.warning(f"Файл не существует: {path}")
                        continue
                    
                    logger.info(f"Файл существует, пробую прямой запуск из директории файла...")
                    # Запускаем из директории файла с относительным путем - это обходит проблемы со скобками
                    try:
                        exiftool_dir = os.path.dirname(path)
                        exiftool_file = os.path.basename(path)
                        logger.debug(f"Директория: {exiftool_dir}, файл: {exiftool_file}")
                        # Запускаем из директории ExifTool с относительным путем
                        result = subprocess.run(
                            [exiftool_file, '-ver'],
                            capture_output=True,
                            text=True,
                            timeout=5,
                            shell=False,
                            cwd=exiftool_dir  # Запускаем из директории ExifTool
                        )
                        logger.info(f"Прямой запуск завершился: код={result.returncode}, stdout={result.stdout[:50] if result.stdout else 'пусто'}")
                    except subprocess.TimeoutExpired:
                        logger.warning(f"Таймаут при прямом запуске: {path}, пробуем cmd.exe")
                        try:
                            logger.info(f"Пробую cmd.exe для пути: {path}")
                            result = subprocess.run(
                                ['cmd.exe', '/c', f'"{path}"', '-ver'],
                                capture_output=True,
                                text=True,
                                timeout=3,
                                shell=False
                            )
                            logger.info(f"cmd.exe завершился: код={result.returncode}")
                        except subprocess.TimeoutExpired:
                            logger.warning(f"Таймаут при проверке через cmd.exe: {path}, пропускаем")
                            continue
                        except Exception as e:
                            logger.warning(f"Ошибка при запуске через cmd.exe: {e}, пропускаем путь")
                            continue
                    except Exception as e:
                        logger.warning(f"Ошибка при прямом запуске: {e}, пробуем cmd.exe")
                        try:
                            logger.info(f"Пробую cmd.exe как fallback для пути: {path}")
                            result = subprocess.run(
                                ['cmd.exe', '/c', f'"{path}"', '-ver'],
                                capture_output=True,
                                text=True,
                                timeout=3,
                                shell=False
                            )
                            logger.info(f"cmd.exe завершился: код={result.returncode}")
                        except subprocess.TimeoutExpired:
                            logger.warning(f"Таймаут при проверке через cmd.exe: {path}, пропускаем")
                            continue
                        except Exception as e2:
                            logger.warning(f"Ошибка при запуске через cmd.exe: {e2}, пропускаем путь")
                            continue
                else:
                    logger.debug(f"Запуск напрямую: {path}")
                    result = subprocess.run(
                        [path, '-ver'],
                        capture_output=True,
                        text=True,
                        timeout=3,  # Уменьшен таймаут
                        shell=False
                    )
                
                logger.debug(f"Результат проверки пути {path}: код={result.returncode}")
                if result.stdout:
                    logger.debug(f"stdout: {result.stdout[:100]}")
                if result.stderr:
                    logger.debug(f"stderr: {result.stderr[:100]}")
                
                if result.returncode == 0:
                    version = result.stdout.strip()
                    logger.info(f"✓ ExifTool найден по пути: {path}, версия: {version}")
                    # Кэшируем результат
                    ImageAnalyzer._exiftool_available = True
                    ImageAnalyzer._exiftool_command = path
                    return True
                else:
                    error_msg = result.stderr[:200] if result.stderr else 'нет сообщения об ошибке'
                    logger.debug(f"ExifTool по пути {path} вернул код ошибки: {result.returncode}, stderr: {error_msg}")
                    # Если это путь со скобками и PowerShell не сработал, пробуем cmd.exe как fallback
                    if platform.system() == 'Windows' and '(' in path and ')' in path:
                        logger.debug(f"Пробуем cmd.exe как fallback для пути со скобками")
                        try:
                            cmd_result = subprocess.run(
                                ['cmd.exe', '/c', f'"{path}"', '-ver'],
                                capture_output=True,
                                text=True,
                                timeout=3,
                                shell=False
                            )
                            if cmd_result.returncode == 0:
                                version = cmd_result.stdout.strip()
                                logger.info(f"✓ ExifTool найден через cmd.exe: {path}, версия: {version}")
                                ImageAnalyzer._exiftool_available = True
                                ImageAnalyzer._exiftool_command = path
                                return True
                        except Exception as e:
                            logger.debug(f"Fallback через cmd.exe также не сработал: {e}")
            except FileNotFoundError as e:
                logger.debug(f"ExifTool не найден по пути {path}: {e}")
                continue
            except subprocess.TimeoutExpired:
                logger.warning(f"Таймаут при проверке ExifTool по пути {path}")
                continue
            except OSError as e:
                logger.debug(f"Ошибка ОС при проверке ExifTool по пути {path}: {e}")
                continue
            except Exception as e:
                logger.error(f"Неожиданная ошибка при проверке ExifTool по пути {path}: {e}", exc_info=True)
                continue
        
        logger.warning("ExifTool не найден ни по одному из путей")
        # Кэшируем отрицательный результат
        ImageAnalyzer._exiftool_available = False
        return False
    
    def _get_exiftool_command(self) -> str:
        """Получение правильной команды exiftool для текущей ОС (с кэшированием)"""
        # Используем кэшированную команду, если она есть
        if ImageAnalyzer._exiftool_command is not None:
            return ImageAnalyzer._exiftool_command
        
        # Если ExifTool недоступен, возвращаем fallback сразу
        if ImageAnalyzer._exiftool_available is False:
            logger.debug("ExifTool недоступен (из кэша), используется fallback")
            return 'exiftool'
        
        paths = self._get_exiftool_paths()
        
        for path in paths:
            try:
                # Для Windows проверяем существование файла
                if platform.system() == 'Windows':
                    # Для путей без расширения (команды в PATH) пропускаем проверку существования
                    if not path.endswith('.exe') and not os.path.exists(path):
                        # Это может быть команда в PATH, пробуем запустить
                        pass
                    elif not os.path.exists(path):
                        logger.debug(f"Файл не существует: {path}")
                        continue
                
                # Для Windows с файлами, содержащими скобки, используем shell=True с кавычками
                if platform.system() == 'Windows' and '(' in path and ')' in path:
                    result = subprocess.run(
                        f'"{path}" -ver',
                        capture_output=True,
                        text=True,
                        timeout=5,
                        shell=True
                    )
                else:
                    result = subprocess.run(
                        [path, '-ver'],
                        capture_output=True,
                        text=True,
                        timeout=5,
                        shell=False
                    )
                
                if result.returncode == 0:
                    version = result.stdout.strip()
                    logger.info(f"✓ ExifTool найден и работает: {path}, версия: {version}")
                    # Кэшируем команду
                    ImageAnalyzer._exiftool_command = path
                    return path
            except FileNotFoundError as e:
                logger.debug(f"ExifTool не найден по пути {path}: {e}")
                continue
            except subprocess.TimeoutExpired:
                logger.warning(f"Таймаут при проверке ExifTool по пути {path}")
                continue
            except OSError as e:
                logger.debug(f"Ошибка ОС при проверке ExifTool по пути {path}: {e}")
                continue
            except Exception as e:
                logger.error(f"Ошибка при проверке ExifTool по пути {path}: {e}")
                continue
        
        logger.warning("ExifTool не найден, будет использован fallback метод")
        # Кэшируем отрицательный результат
        ImageAnalyzer._exiftool_command = 'exiftool'
        return 'exiftool'  # Fallback
    
    def _extract_with_exiftool(self, file_path: str) -> Dict[str, Any]:
        """Извлечение метаданных с помощью exiftool (самый мощный метод)"""
        exif_data = {}
        exiftool_cmd = self._get_exiftool_command()
        
        # Проверяем, что команда не fallback
        if exiftool_cmd == 'exiftool' and platform.system() == 'Windows':
            logger.warning("Используется fallback команда 'exiftool', которая может не работать на Windows")
            exif_data['_exiftool_error'] = "ExifTool не найден в системе"
            return exif_data
        
        # Проверяем существование файла
        if not os.path.exists(file_path):
            logger.error(f"Файл для анализа не существует: {file_path}")
            exif_data['_exiftool_error'] = f"Файл не найден: {file_path}"
            return exif_data
        
        try:
            logger.debug(f"Запуск ExifTool: {exiftool_cmd} для файла: {file_path}")
            
            # Использование exiftool для полного извлечения метаданных
            # -j: JSON формат
            # -G: Группировка по тегам (EXIF:, XMP:, IPTC:, CBOR:)
            # -a: Все теги, включая дубликаты
            # -u: Неизвестные теги
            # -n: Числовые значения (без форматирования)
            # Уменьшен таймаут с 30 до 15 секунд для предотвращения зависаний
            
            logger.info(f"Начало извлечения метаданных через ExifTool (таймаут: 10 сек)")
            logger.info(f"Команда: {exiftool_cmd}")
            logger.info(f"Файл: {file_path}")
            
            # Для Windows с файлами, содержащими скобки, используем прямой запуск из директории
            if platform.system() == 'Windows' and '(' in exiftool_cmd and ')' in exiftool_cmd:
                logger.info(f"Выполнение команды ExifTool (путь со скобками): {exiftool_cmd}")
                # Запускаем из директории ExifTool с относительным путем - это обходит проблемы со скобками
                try:
                    exiftool_dir = os.path.dirname(exiftool_cmd)
                    exiftool_file = os.path.basename(exiftool_cmd)
                    logger.debug(f"Директория: {exiftool_dir}, файл: {exiftool_file}")
                    result = subprocess.run(
                        [exiftool_file, '-j', '-G', '-a', '-u', '-n', file_path],
                        capture_output=True,
                        text=True,
                        timeout=15,
                        shell=False,
                        cwd=exiftool_dir  # Запускаем из директории ExifTool
                    )
                except subprocess.TimeoutExpired as e:
                    logger.error(f"Таймаут при выполнении ExifTool: {e}")
                    raise
                except Exception as e:
                    logger.warning(f"Ошибка при прямом запуске: {e}, пробуем cmd.exe")
                    # Fallback на cmd.exe
                    try:
                        result = subprocess.run(
                            ['cmd.exe', '/c', f'"{exiftool_cmd}"', '-j', '-G', '-a', '-u', '-n', f'"{file_path}"'],
                            capture_output=True,
                            text=True,
                            timeout=15,
                            shell=False
                        )
                    except Exception as e2:
                        logger.error(f"Ошибка при выполнении через cmd.exe: {e2}")
                        raise
            else:
                logger.debug(f"Выполнение команды: {[exiftool_cmd, '-j', '-G', '-a', '-u', '-n', file_path]}")
                result = subprocess.run(
                    [exiftool_cmd, '-j', '-G', '-a', '-u', '-n', file_path],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    shell=False
                )
            
            logger.debug(f"ExifTool завершился с кодом: {result.returncode}")
            
            if result.returncode == 0:
                logger.info("ExifTool успешно выполнен")
                if result.stdout:
                    try:
                        data = json.loads(result.stdout)
                        if data and len(data) > 0:
                            # exiftool возвращает список с одним словарем
                            exif_data = data[0]
                            logger.debug(f"ExifTool успешно извлек {len(exif_data)} полей метаданных")
                            # Сохраняем версию ExifTool для отображения
                            if 'ExifTool:ExifToolVersion' in exif_data:
                                exif_data['ExifTool:Version'] = exif_data.pop('ExifTool:ExifToolVersion')
                            # Удаляем служебные поля
                            exif_data.pop('SourceFile', None)
                        else:
                            logger.warning("ExifTool вернул пустые данные")
                            exif_data['_exiftool_error'] = "Пустой ответ от ExifTool"
                    except json.JSONDecodeError as e:
                        logger.error(f"Ошибка парсинга JSON от ExifTool: {e}")
                        logger.error(f"Ответ ExifTool: {result.stdout[:1000]}")
                        exif_data['_exiftool_error'] = f"Ошибка парсинга JSON: {str(e)}"
                else:
                    logger.warning("ExifTool не вернул данных (пустой stdout)")
                    exif_data['_exiftool_error'] = "Пустой ответ от ExifTool"
            else:
                logger.error(f"ExifTool завершился с ошибкой. Код: {result.returncode}, stderr: {result.stderr}")
                exif_data['_exiftool_error'] = f"ExifTool ошибка (код {result.returncode}): {result.stderr[:200] if result.stderr else 'нет сообщения об ошибке'}"
            
        except FileNotFoundError as e:
            logger.error(f"ExifTool не найден: {e}")
            exif_data['_exiftool_error'] = f"ExifTool не найден: {str(e)}"
        except subprocess.TimeoutExpired as e:
            logger.error(f"Таймаут при выполнении ExifTool (превышен лимит 15 секунд): {e}")
            exif_data['_exiftool_error'] = "Таймаут выполнения ExifTool (превышен лимит 15 секунд). Файл может быть слишком большим или поврежденным."
        except json.JSONDecodeError as e:
            logger.error(f"Ошибка парсинга JSON: {e}")
            exif_data['_exiftool_error'] = f"Ошибка парсинга JSON: {str(e)}"
        except Exception as e:
            logger.error(f"Неожиданная ошибка ExifTool: {e}", exc_info=True)
            exif_data['_exiftool_error'] = f"Ошибка exiftool: {str(e)}"
        
        return exif_data
    
    def extract_exif_data(self, file_path: str) -> Dict[str, Any]:
        """Извлечение EXIF данных из изображения (комбинированный подход)"""
        import time
        start_time = time.time()
        exif_data = {}
        
        logger.info(f"Начало извлечения EXIF данных из файла: {file_path}")
        
        # Сначала пробуем exiftool (самый мощный)
        logger.info("Проверка доступности ExifTool перед извлечением...")
        exiftool_available = self._check_exiftool_available()
        logger.info(f"Результат проверки ExifTool: {'доступен' if exiftool_available else 'недоступен'}")
        
        if exiftool_available:
            logger.info("ExifTool доступен, начинаю извлечение метаданных...")
            exiftool_start = time.time()
            exiftool_data = self._extract_with_exiftool(file_path)
            exiftool_time = time.time() - exiftool_start
            logger.info(f"ExifTool завершил извлечение за {exiftool_time:.2f} сек")
            
            if exiftool_data:
                if '_exiftool_error' in exiftool_data:
                    error_msg = exiftool_data['_exiftool_error']
                    logger.warning(f"ExifTool вернул ошибку: {error_msg}")
                    logger.info("Используется fallback метод")
                else:
                    # Конвертируем данные exiftool в наш формат
                    logger.info("Начало конвертации данных ExifTool...")
                    convert_start = time.time()
                    try:
                        exif_data = self._convert_exiftool_data(exiftool_data)
                        convert_time = time.time() - convert_start
                        logger.info(f"Конвертация завершена за {convert_time:.2f} сек")
                        # Если exiftool успешно извлек данные, используем их
                        if exif_data:
                            grouped_count = len(exif_data.get('_grouped_metadata', {}))
                            total_fields = sum(len(v) for v in exif_data.get('_grouped_metadata', {}).values())
                            logger.info(f"✓ ExifTool успешно извлек {grouped_count} секций с {total_fields} полями метаданных")
                            total_time = time.time() - start_time
                            logger.info(f"Извлечение EXIF данных завершено за {total_time:.2f} сек")
                            return exif_data
                        else:
                            logger.warning("ExifTool вернул данные, но конвертация не удалась")
                    except Exception as e:
                        logger.error(f"Ошибка при конвертации данных ExifTool: {e}", exc_info=True)
                        logger.info("Используется fallback метод")
            else:
                logger.warning("ExifTool вернул пустые данные, используется fallback")
        else:
            logger.info("ExifTool недоступен, используется fallback метод")
        
        # Fallback на exifread и PIL
        logger.info("Использование fallback метода (exifread/PIL)...")
        fallback_start = time.time()
        try:
            # Использование exifread для чтения EXIF
            with open(file_path, 'rb') as f:
                tags = exifread.process_file(f, details=True)
                
                logger.info(f"Exifread извлек {len(tags)} тегов")
                
                # Создаем группированные метаданные для отображения
                grouped_metadata = {
                    'EXIF': [],
                    'Image': [],
                    'GPS': [],
                    'Thumbnail': [],
                    'Interoperability': [],
                    'Other': []
                }
                
                # Основные метаданные
                if 'EXIF DateTimeOriginal' in tags:
                    exif_data['date_time'] = str(tags['EXIF DateTimeOriginal'])
                    grouped_metadata['EXIF'].append(['DateTimeOriginal', str(tags['EXIF DateTimeOriginal'])])
                elif 'Image DateTime' in tags:
                    exif_data['date_time'] = str(tags['Image DateTime'])
                    grouped_metadata['Image'].append(['DateTime', str(tags['Image DateTime'])])
                
                if 'Image Make' in tags:
                    exif_data['camera_make'] = str(tags['Image Make'])
                    grouped_metadata['Image'].append(['Make', str(tags['Image Make'])])
                if 'Image Model' in tags:
                    exif_data['camera_model'] = str(tags['Image Model'])
                    grouped_metadata['Image'].append(['Model', str(tags['Image Model'])])
                
                # GPS координаты
                if 'GPS GPSLatitude' in tags and 'GPS GPSLongitude' in tags:
                    try:
                        lat = self._convert_to_degrees(tags['GPS GPSLatitude'])
                        lon = self._convert_to_degrees(tags['GPS GPSLongitude'])
                        if tags.get('GPS GPSLatitudeRef') == 'S':
                            lat = -lat
                        if tags.get('GPS GPSLongitudeRef') == 'W':
                            lon = -lon
                        exif_data['gps'] = {
                            'latitude': lat,
                            'longitude': lon
                        }
                        grouped_metadata['GPS'].append(['Latitude', str(lat)])
                        grouped_metadata['GPS'].append(['Longitude', str(lon)])
                    except Exception as e:
                        logger.debug(f"Ошибка конвертации GPS: {e}")
                
                # Параметры съемки
                if 'EXIF ISOSpeedRatings' in tags:
                    exif_data['iso'] = str(tags['EXIF ISOSpeedRatings'])
                    grouped_metadata['EXIF'].append(['ISO', str(tags['EXIF ISOSpeedRatings'])])
                if 'EXIF ExposureTime' in tags:
                    exif_data['exposure_time'] = str(tags['EXIF ExposureTime'])
                    grouped_metadata['EXIF'].append(['ExposureTime', str(tags['EXIF ExposureTime'])])
                if 'EXIF FNumber' in tags:
                    exif_data['f_number'] = str(tags['EXIF FNumber'])
                    grouped_metadata['EXIF'].append(['FNumber', str(tags['EXIF FNumber'])])
                if 'EXIF FocalLength' in tags:
                    exif_data['focal_length'] = str(tags['EXIF FocalLength'])
                    grouped_metadata['EXIF'].append(['FocalLength', str(tags['EXIF FocalLength'])])
                
                # Software
                if 'Image Software' in tags:
                    exif_data['software'] = str(tags['Image Software'])
                    grouped_metadata['Image'].append(['Software', str(tags['Image Software'])])
                elif 'EXIF Software' in tags:
                    exif_data['software'] = str(tags['EXIF Software'])
                    grouped_metadata['EXIF'].append(['Software', str(tags['EXIF Software'])])
                
                # Размеры изображения
                if 'EXIF ExifImageWidth' in tags:
                    exif_data['width'] = int(str(tags['EXIF ExifImageWidth']))
                    grouped_metadata['EXIF'].append(['ExifImageWidth', str(tags['EXIF ExifImageWidth'])])
                if 'EXIF ExifImageLength' in tags:
                    exif_data['height'] = int(str(tags['EXIF ExifImageLength']))
                    grouped_metadata['EXIF'].append(['ExifImageLength', str(tags['EXIF ExifImageLength'])])
                
                # Добавляем все остальные теги в группированные метаданные
                for tag_name, tag_value in tags.items():
                    tag_str = str(tag_name)
                    value_str = str(tag_value)
                    
                    # Пропускаем уже обработанные теги
                    if tag_name in ['EXIF DateTimeOriginal', 'Image DateTime', 'Image Make', 'Image Model',
                                   'GPS GPSLatitude', 'GPS GPSLongitude', 'EXIF ISOSpeedRatings',
                                   'EXIF ExposureTime', 'EXIF FNumber', 'EXIF FocalLength',
                                   'Image Software', 'EXIF Software', 'EXIF ExifImageWidth', 'EXIF ExifImageLength']:
                        continue
                    
                    # Группируем по префиксу
                    if tag_str.startswith('EXIF '):
                        clean_name = tag_str.replace('EXIF ', '')
                        grouped_metadata['EXIF'].append([clean_name, value_str])
                    elif tag_str.startswith('Image '):
                        clean_name = tag_str.replace('Image ', '')
                        grouped_metadata['Image'].append([clean_name, value_str])
                    elif tag_str.startswith('GPS '):
                        clean_name = tag_str.replace('GPS ', '')
                        grouped_metadata['GPS'].append([clean_name, value_str])
                    elif tag_str.startswith('Thumbnail '):
                        clean_name = tag_str.replace('Thumbnail ', '')
                        grouped_metadata['Thumbnail'].append([clean_name, value_str])
                    elif tag_str.startswith('Interoperability '):
                        clean_name = tag_str.replace('Interoperability ', '')
                        grouped_metadata['Interoperability'].append([clean_name, value_str])
                    else:
                        grouped_metadata['Other'].append([tag_str, value_str])
                
                # Удаляем пустые секции
                grouped_metadata = {k: v for k, v in grouped_metadata.items() if v}
                
                # Сохраняем группированные метаданные из exifread
                if grouped_metadata:
                    if '_grouped_metadata' not in exif_data:
                        exif_data['_grouped_metadata'] = {}
                    # Объединяем с уже существующими метаданными из PIL
                    for section, items in grouped_metadata.items():
                        if section in exif_data['_grouped_metadata']:
                            exif_data['_grouped_metadata'][section].extend(items)
                        else:
                            exif_data['_grouped_metadata'][section] = items
                    
                    total_fields = sum(len(v) for v in grouped_metadata.values())
                    logger.info(f"Exifread добавил {len(grouped_metadata)} секций с {total_fields} полями метаданных")
        
        except Exception as e:
            logger.error(f"Ошибка чтения EXIF через fallback метод: {str(e)}", exc_info=True)
            exif_data['error'] = f"Ошибка чтения EXIF: {str(e)}"
        
        # Дополнительная проверка через PIL для извлечения всех доступных метаданных
        try:
            with Image.open(file_path) as img:
                logger.info(f"Изображение открыто через PIL: формат={img.format}, размер={img.size}, режим={img.mode}")
                
                # Базовые метаданные изображения
                if 'width' not in exif_data:
                    exif_data['width'] = img.width
                if 'height' not in exif_data:
                    exif_data['height'] = img.height
                
                # Добавляем в группированные метаданные
                if '_grouped_metadata' not in exif_data:
                    exif_data['_grouped_metadata'] = {}
                if 'File' not in exif_data['_grouped_metadata']:
                    exif_data['_grouped_metadata']['File'] = []
                
                exif_data['_grouped_metadata']['File'].append(['Format', img.format or 'Unknown'])
                exif_data['_grouped_metadata']['File'].append(['Width', str(img.width)])
                exif_data['_grouped_metadata']['File'].append(['Height', str(img.height)])
                exif_data['_grouped_metadata']['File'].append(['Mode', img.mode])
                
                # Для PNG файлов извлекаем метаданные из chunks
                if img.format == 'PNG':
                    logger.info("Обработка PNG файла - извлечение chunks метаданных")
                    if 'PNG' not in exif_data['_grouped_metadata']:
                        exif_data['_grouped_metadata']['PNG'] = []
                    
                    # PNG chunks доступны через img.text (для tEXt chunks)
                    if hasattr(img, 'text') and img.text:
                        logger.info(f"Найдены PNG text chunks: {len(img.text)} элементов")
                        for key, value in img.text.items():
                            exif_data['_grouped_metadata']['PNG'].append([f'tEXt:{key}', str(value)])
                            # Проверяем на XMP данные
                            if 'xmp' in key.lower() or 'xml' in key.lower():
                                if 'XMP' not in exif_data['_grouped_metadata']:
                                    exif_data['_grouped_metadata']['XMP'] = []
                                exif_data['_grouped_metadata']['XMP'].append([key, str(value)[:500]])  # Ограничиваем длину
                    
                    # Проверяем img.info на наличие PNG-specific метаданных
                    if img.info:
                        png_info_keys = ['transparency', 'gamma', 'chroma', 'icc_profile', 'dpi', 'compression']
                        for key in png_info_keys:
                            if key in img.info:
                                value = img.info[key]
                                if isinstance(value, bytes):
                                    if key == 'icc_profile':
                                        exif_data['_grouped_metadata']['PNG'].append([key, f"<ICC profile {len(value)} bytes>"])
                                    else:
                                        exif_data['_grouped_metadata']['PNG'].append([key, f"<binary data {len(value)} bytes>"])
                                else:
                                    exif_data['_grouped_metadata']['PNG'].append([key, str(value)])
                
                # EXIF данные через PIL
                exif_bytes = img.info.get('exif', None)
                logger.info(f"EXIF данные в img.info: {'найдены' if exif_bytes else 'отсутствуют'}")
                
                if exif_bytes:
                    try:
                        exif_dict = piexif.load(exif_bytes)
                        logger.info(f"EXIF словарь загружен, секции: {list(exif_dict.keys())}")
                        
                        # Обрабатываем все секции EXIF
                        for ifd_name in ['0th', 'Exif', 'GPS', 'Interop', '1st', 'thumbnail']:
                            if ifd_name in exif_dict and exif_dict[ifd_name]:
                                section_name = ifd_name.upper() if ifd_name != '0th' else 'Image'
                                if section_name not in exif_data['_grouped_metadata']:
                                    exif_data['_grouped_metadata'][section_name] = []
                                
                                tag_count = 0
                                for tag_id, tag_value in exif_dict[ifd_name].items():
                                    try:
                                        tag_name = TAGS.get(tag_id, f"Tag_{tag_id}")
                                        if isinstance(tag_value, bytes):
                                            try:
                                                tag_value = tag_value.decode('utf-8', errors='ignore')
                                            except:
                                                tag_value = f"<binary data {len(tag_value)} bytes>"
                                        exif_data['_grouped_metadata'][section_name].append([tag_name, str(tag_value)])
                                        tag_count += 1
                                    except Exception as e:
                                        logger.debug(f"Ошибка обработки тега {tag_id}: {e}")
                                
                                if tag_count > 0:
                                    logger.info(f"Добавлено {tag_count} тегов в секцию {section_name}")
                    except Exception as e:
                        logger.error(f"Ошибка загрузки EXIF через piexif: {e}", exc_info=True)
                
                # Также пробуем через _getexif для старых версий PIL
                elif hasattr(img, '_getexif') and img._getexif() is not None:
                    logger.info("Найдены EXIF данные через PIL._getexif (старый метод)")
                    try:
                        exif_dict = piexif.load(img.info.get('exif', b''))
                        if exif_dict:
                            # Обрабатываем все секции EXIF
                            for ifd_name in ['0th', 'Exif', 'GPS', 'Interop', '1st', 'thumbnail']:
                                if ifd_name in exif_dict and exif_dict[ifd_name]:
                                    section_name = ifd_name.upper() if ifd_name != '0th' else 'Image'
                                    if section_name not in exif_data['_grouped_metadata']:
                                        exif_data['_grouped_metadata'][section_name] = []
                                    
                                    for tag_id, tag_value in exif_dict[ifd_name].items():
                                        try:
                                            tag_name = TAGS.get(tag_id, f"Tag_{tag_id}")
                                            if isinstance(tag_value, bytes):
                                                try:
                                                    tag_value = tag_value.decode('utf-8', errors='ignore')
                                                except:
                                                    tag_value = f"<binary data {len(tag_value)} bytes>"
                                            exif_data['_grouped_metadata'][section_name].append([tag_name, str(tag_value)])
                                        except Exception as e:
                                            logger.debug(f"Ошибка обработки тега {tag_id}: {e}")
                    except Exception as e:
                        logger.error(f"Ошибка обработки EXIF через _getexif: {e}", exc_info=True)
                
                # Дополнительные метаданные из img.info
                if img.info:
                    if 'Image' not in exif_data['_grouped_metadata']:
                        exif_data['_grouped_metadata']['Image'] = []
                    for key, value in img.info.items():
                        if key not in ['exif', 'icc_profile']:  # Пропускаем бинарные данные
                            try:
                                if isinstance(value, bytes):
                                    value = f"<binary data {len(value)} bytes>"
                                exif_data['_grouped_metadata']['Image'].append([key, str(value)])
                            except Exception as e:
                                logger.debug(f"Ошибка обработки info.{key}: {e}")
                
                # Software из EXIF
                if hasattr(img, '_getexif') and img._getexif() is not None:
                    try:
                        exif_dict = piexif.load(img.info.get('exif', b''))
                        if exif_dict and '0th' in exif_dict:
                            if piexif.ImageIFD.Software in exif_dict['0th']:
                                software = exif_dict['0th'][piexif.ImageIFD.Software].decode('utf-8')
                                if 'software' not in exif_data:
                                    exif_data['software'] = software
                    except:
                        pass
        except Exception as e:
            logger.error(f"Ошибка при дополнительной проверке через PIL: {e}", exc_info=True)
        
        fallback_time = time.time() - fallback_start
        
        # Подсчитываем итоговое количество метаданных
        if '_grouped_metadata' in exif_data:
            total_sections = len(exif_data['_grouped_metadata'])
            total_fields = sum(len(v) for v in exif_data['_grouped_metadata'].values())
            logger.info(f"Итого извлечено метаданных: {total_sections} секций, {total_fields} полей")
        else:
            logger.warning("Группированные метаданные не созданы")
        
        total_time = time.time() - start_time
        logger.info(f"Fallback метод завершен за {fallback_time:.2f} сек, общее время извлечения EXIF: {total_time:.2f} сек")
        
        return exif_data
    
    def _convert_exiftool_data(self, exiftool_data: Dict[str, Any]) -> Dict[str, Any]:
        """Конвертация данных exiftool в наш формат с группировкой по секциям"""
        import time
        start_time = time.time()
        logger.info(f"Начало конвертации данных ExifTool, количество полей: {len(exiftool_data)}")
        converted = {}
        grouped_metadata = {}  # Группировка по секциям для отображения
        
        # Маппинг основных полей (date_time обрабатывается отдельно с приоритетом)
        field_mapping = {
            'EXIF:Make': 'camera_make',
            'EXIF:Model': 'camera_model',
            'EXIF:ISO': 'iso',
            'EXIF:ExposureTime': 'exposure_time',
            'EXIF:FNumber': 'f_number',
            'EXIF:FocalLength': 'focal_length',
            'EXIF:Software': 'software',
            'EXIF:ExifImageWidth': 'width',
            'EXIF:ExifImageHeight': 'height',
            'EXIF:ImageWidth': 'width',
            'EXIF:ImageHeight': 'height',
            'EXIF:GPSLatitude': 'gps_latitude',
            'EXIF:GPSLongitude': 'gps_longitude',
            'EXIF:GPSLatitudeRef': 'gps_latitude_ref',
            'EXIF:GPSLongitudeRef': 'gps_longitude_ref',
        }
        
        # Группировка всех метаданных по секциям
        sections = {
            'ExifTool': [],
            'System': [],
            'File': [],
            'PNG': [],
            'JPEG': [],
            'TIFF': [],
            'EXIF': [],
            'GPS': [],
            'XMP': [],
            'IPTC': [],
            'JUMBF': [],
            'CBOR': [],
            'C2PA': [],
            'Jpeg2000': [],
            'Composite': [],
            'Other': []
        }
        
        # Обработка GPS координат
        if 'EXIF:GPSLatitude' in exiftool_data and 'EXIF:GPSLongitude' in exiftool_data:
            try:
                lat = float(exiftool_data.get('EXIF:GPSLatitude', 0))
                lon = float(exiftool_data.get('EXIF:GPSLongitude', 0))
                lat_ref = exiftool_data.get('EXIF:GPSLatitudeRef', 'N')
                lon_ref = exiftool_data.get('EXIF:GPSLongitudeRef', 'E')
                
                if lat_ref == 'S':
                    lat = -lat
                if lon_ref == 'W':
                    lon = -lon
                
                converted['gps'] = {
                    'latitude': lat,
                    'longitude': lon
                }
            except (ValueError, TypeError):
                pass
        
        # Группируем все поля по секциям
        logger.debug(f"Начало группировки {len(exiftool_data)} полей по секциям...")
        grouping_start = time.time()
        processed_count = 0
        for key, value in exiftool_data.items():
            processed_count += 1
            if processed_count % 100 == 0:
                logger.debug(f"Обработано {processed_count}/{len(exiftool_data)} полей...")
            # Пропускаем служебные поля
            if key in ['SourceFile', 'ExifToolVersion']:
                continue
                
            if key.startswith('ExifTool:'):
                sections['ExifTool'].append((key.replace('ExifTool:', ''), value))
            elif key.startswith('System:'):
                sections['System'].append((key.replace('System:', ''), value))
            elif key.startswith('File:'):
                sections['File'].append((key.replace('File:', ''), value))
            elif key.startswith('PNG:'):
                sections['PNG'].append((key.replace('PNG:', ''), value))
            elif key.startswith('JPEG:'):
                sections['JPEG'].append((key.replace('JPEG:', ''), value))
            elif key.startswith('TIFF:'):
                sections['TIFF'].append((key.replace('TIFF:', ''), value))
            elif key.startswith('EXIF:'):
                sections['EXIF'].append((key.replace('EXIF:', ''), value))
            elif key.startswith('GPS:'):
                sections['GPS'].append((key.replace('GPS:', ''), value))
            elif key.startswith('XMP:'):
                sections['XMP'].append((key.replace('XMP:', ''), value))
            elif key.startswith('IPTC:'):
                sections['IPTC'].append((key.replace('IPTC:', ''), value))
            elif key.startswith('JUMBF:') or 'JUMD' in key.upper():
                sections['JUMBF'].append((key.replace('JUMBF:', ''), value))
            elif key.startswith('CBOR:'):
                sections['CBOR'].append((key.replace('CBOR:', ''), value))
            elif 'C2PA' in key.upper() and not key.startswith('CBOR:'):
                sections['C2PA'].append((key, value))
            elif key.startswith('Jpeg2000:'):
                sections['Jpeg2000'].append((key.replace('Jpeg2000:', ''), value))
            elif key.startswith('Composite:'):
                sections['Composite'].append((key.replace('Composite:', ''), value))
            else:
                # Проверяем на C2PA в других форматах
                if 'C2PA' in key.upper() or 'CBOR' in key.upper():
                    sections['CBOR'].append((key, value))
                else:
                    sections['Other'].append((key, value))
        
        # Сохраняем сгруппированные метаданные (только непустые секции)
        # Явно строим списки [tag, value] из section_data, чтобы не захватывать внешние переменные
        grouped_metadata = {}
        for section_name, section_data in sections.items():
            if section_data:
                rows = []
                for entry in section_data:
                    if isinstance(entry, tuple):
                        tag_name, tag_value = entry[0], entry[1]
                        rows.append([str(tag_name), str(tag_value)])
                    else:
                        rows.append(list(entry))
                grouped_metadata[section_name] = rows
        converted['_grouped_metadata'] = grouped_metadata
        # Отладка: первые ключи и первые строки секции File
        if exiftool_data:
            sample_keys = list(exiftool_data.keys())[:5]
            logger.info(f"ExifTool sample keys: {sample_keys}")
        if sections.get('File'):
            logger.info(f"File section sample (first 2): {sections['File'][:2]}")
        
        # Конвертация date_time с правильным приоритетом (только EXIF дата съёмки, не время файла)
        if 'EXIF:DateTimeOriginal' in exiftool_data:
            converted['date_time'] = str(exiftool_data['EXIF:DateTimeOriginal'])
            logger.info(f"date_time установлен из EXIF:DateTimeOriginal: {converted['date_time']}")
        elif 'EXIF:CreateDate' in exiftool_data:
            converted['date_time'] = str(exiftool_data['EXIF:CreateDate'])
            logger.info(f"date_time установлен из EXIF:CreateDate: {converted['date_time']}")
        else:
            logger.info("date_time не установлен - нет EXIF даты съёмки (DateTimeOriginal или CreateDate)")
        # НЕ используем File:FileModifyDate или другие поля времени файла
        
        # Конвертация основных полей для обратной совместимости
        for exiftool_key, our_key in field_mapping.items():
            if exiftool_key in exiftool_data:
                value = exiftool_data[exiftool_key]
                # Пропускаем GPS поля, они обработаны отдельно
                if 'GPS' not in exiftool_key:
                    converted[our_key] = str(value)
        
        # Добавляем все остальные поля EXIF
        for key, value in exiftool_data.items():
            if key.startswith('EXIF:') and key not in field_mapping:
                # Убираем префикс EXIF: и нормализуем ключ
                clean_key = key.replace('EXIF:', '').replace(':', '_').lower()
                # Пропускаем служебные поля
                if clean_key not in ['exiftoolversion', 'sourcefile'] and clean_key not in converted:
                    converted[clean_key] = str(value)
        
        # Сохраняем сгруппированные метаданные (если еще не сохранены)
        if '_grouped_metadata' not in converted:
            # Конвертируем кортежи в списки для JSON сериализации
            grouped_metadata = {}
            for section_name, section_data in sections.items():
                if section_data:  # Только непустые секции
                    grouped_metadata[section_name] = [
                        [item[0], item[1]] if isinstance(item, tuple) else list(item)
                        for item in section_data
                    ]
            converted['_grouped_metadata'] = grouped_metadata
        
        # Добавляем XMP данные если есть
        xmp_fields = {}
        for key, value in exiftool_data.items():
            if key.startswith('XMP:'):
                clean_key = key.replace('XMP:', '').replace(':', '_').lower()
                xmp_fields[clean_key] = str(value)
        
        if xmp_fields:
            converted['_xmp_from_exiftool'] = xmp_fields
        
        # Добавляем IPTC данные если есть
        iptc_fields = {}
        for key, value in exiftool_data.items():
            if key.startswith('IPTC:'):
                clean_key = key.replace('IPTC:', '').replace(':', '_').lower()
                iptc_fields[clean_key] = str(value)
        
        if iptc_fields:
            converted['_iptc_from_exiftool'] = iptc_fields
        
        # Извлекаем C2PA метаданные (Content Authenticity Initiative) — основа для фактологического вывода
        c2pa_fields = {}
        c2pa_indicators = []
        c2pa_manifest_types = []  # c2pa.claim.v2, c2pa.actions.v2, c2pa.signature, c2pa.ingredient.v3
        
        # Явные маппинги тегов ExifTool (CBOR/JUMBF) на наши ключи
        c2pa_key_fields = {
            'CBOR:Actions Software Agent Name': 'c2pa_software_agent',
            'CBOR:Claim Generator Info Name': 'c2pa_generator_name',
            'CBOR:Claim Generator Info Org Contentauth C2 Pa Rs': 'c2pa_generator_version',
            'CBOR:Actions Digital Source Type': 'c2pa_digital_source_type',
            'CBOR:Actions Action': 'c2pa_actions',
            'CBOR:Active Manifest Url': 'c2pa_active_manifest',
            'CBOR:Claim Signature Url': 'c2pa_signature',
        }
        
        # Варианты названий тегов (с пробелами и без)
        c2pa_key_aliases = [
            ('CBOR:ActionsSoftwareAgentName', 'c2pa_software_agent'),
            ('CBOR:ClaimGeneratorInfoName', 'c2pa_generator_name'),
            ('CBOR:ActionsDigitalSourceType', 'c2pa_digital_source_type'),
            ('CBOR:ActionsAction', 'c2pa_actions'),
            ('CBOR:ValidationResultsActiveManifestSuccessCode', 'c2pa_validation_success'),
            ('CBOR:Validation Results Active Manifest Success Code', 'c2pa_validation_success'),
        ]
        
        for exiftool_key, our_key in c2pa_key_fields.items():
            if exiftool_key in exiftool_data:
                value = exiftool_data[exiftool_key]
                c2pa_fields[our_key] = str(value)
        
        for exiftool_key, our_key in c2pa_key_aliases:
            if exiftool_key in exiftool_data and our_key not in c2pa_fields:
                c2pa_fields[our_key] = str(exiftool_data[exiftool_key])
        
        # Краткие индикаторы для detect_ai_software (обратная совместимость)
        if c2pa_fields.get('c2pa_software_agent'):
            c2pa_indicators.append(f"C2PA: {c2pa_fields['c2pa_software_agent']}")
        if c2pa_fields.get('c2pa_generator_name'):
            c2pa_indicators.append(f"C2PA Generator: {c2pa_fields['c2pa_generator_name']}")
        if c2pa_fields.get('c2pa_digital_source_type') and ('trainedAlgorithmicMedia' in str(c2pa_fields.get('c2pa_digital_source_type')) or 'algorithmic' in str(c2pa_fields.get('c2pa_digital_source_type')).lower()):
            c2pa_indicators.append("C2PA: Trained Algorithmic Media (ИИ-контент)")
        
        # Все CBOR/C2PA поля + нормализованные имена для поиска по подстроке
        for key, value in exiftool_data.items():
            key_upper = key.upper()
            val_str = str(value)
            if 'JUMBF' in key_upper and 'c2pa.' in val_str.lower():
                # Манифесты C2PA в JUMBF (c2pa.claim.v2, c2pa.actions.v2, c2pa.signature, c2pa.ingredient.v3)
                if val_str.strip() not in c2pa_manifest_types:
                    c2pa_manifest_types.append(val_str.strip())
            if 'C2PA' in key_upper or 'CBOR' in key_upper:
                clean_key = key.replace('CBOR:', '').replace('JUMBF:', '').replace(':', '_').replace(' ', '_').lower()
                if clean_key not in c2pa_fields:
                    c2pa_fields[clean_key] = val_str
                if 'validation' in clean_key and ('success' in clean_key or 'valid' in val_str.lower()):
                    c2pa_fields['c2pa_validation_success'] = c2pa_fields.get('c2pa_validation_success') or val_str
        
        if c2pa_manifest_types:
            converted['_c2pa_manifest_types'] = c2pa_manifest_types
        if c2pa_fields:
            converted['_c2pa_metadata'] = c2pa_fields
            converted['_c2pa_indicators'] = c2pa_indicators
        
        # Убеждаемся, что _grouped_metadata сохранен (если еще не был сохранен выше)
        if '_grouped_metadata' not in converted:
            grouped_metadata = {}
            for section_name, section_data in sections.items():
                if section_data:
                    grouped_metadata[section_name] = [
                        [entry[0], entry[1]] if isinstance(entry, tuple) else list(entry)
                        for entry in section_data
                    ]
            converted['_grouped_metadata'] = grouped_metadata
        
        total_time = time.time() - start_time
        gm = converted.get('_grouped_metadata', {})
        logger.info(f"Конвертация данных ExifTool завершена за {total_time:.2f} сек, создано {len(gm)} секций")
        
        return converted
    
    def extract_xmp_data(self, file_path: str) -> Dict[str, Any]:
        """Извлечение XMP/IPTC данных (улучшенная версия)"""
        xmp_data = {}
        
        # Сначала пробуем exiftool для более полного извлечения
        if self._check_exiftool_available():
            exiftool_cmd = self._get_exiftool_command()
            try:
                result = subprocess.run(
                    [exiftool_cmd, '-XMP:All', '-IPTC:All', '-j', file_path],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                if result.returncode == 0 and result.stdout:
                    data = json.loads(result.stdout)
                    if data and len(data) > 0:
                        exiftool_data = data[0]
                        
                        # Извлекаем XMP поля
                        xmp_fields = {}
                        for key, value in exiftool_data.items():
                            if key.startswith('XMP:'):
                                clean_key = key.replace('XMP:', '').replace(':', '_')
                                xmp_fields[clean_key] = str(value)
                        
                        if xmp_fields:
                            xmp_data.update(xmp_fields)
                        
                        # Извлекаем IPTC поля
                        iptc_fields = {}
                        for key, value in exiftool_data.items():
                            if key.startswith('IPTC:'):
                                clean_key = key.replace('IPTC:', '').replace(':', '_')
                                iptc_fields[clean_key] = str(value)
                        
                        if iptc_fields:
                            xmp_data['iptc'] = iptc_fields
            except Exception:
                pass  # Fallback на PIL
        
        # Fallback на PIL для базового извлечения
        try:
            with Image.open(file_path) as img:
                # XMP данные обычно хранятся в img.info
                if 'xmp' in img.info:
                    if 'raw_xmp' not in xmp_data:
                        xmp_data['raw_xmp'] = img.info['xmp']
                
                # IPTC данные
                if 'iptc' in img.info:
                    if 'iptc' not in xmp_data:
                        xmp_data['iptc'] = img.info['iptc']
                
                # Дополнительные метаданные из img.info
                for key, value in img.info.items():
                    if key not in ['xmp', 'iptc', 'exif'] and key not in xmp_data:
                        # Добавляем другие метаданные
                        if isinstance(value, (str, int, float)):
                            xmp_data[f'info_{key}'] = str(value)
        except Exception as e:
            if not xmp_data:
                xmp_data['error'] = f"Ошибка чтения XMP: {str(e)}"
        
        return xmp_data
    
    def analyze_image_characteristics(self, file_path: str, exif_data: Dict) -> Dict[str, Any]:
        """Анализ характеристик изображения для выявления признаков ИИ"""
        characteristics = {
            "width": None,
            "height": None,
            "aspect_ratio": None,
            "is_square": False,
            "is_standard_ai_size": False,
            "has_gps": False,
            "has_camera_info": False,
            "has_shooting_params": False,
            "suspicious_features": [],
            "file_format": None,
            "supports_exif": True
        }
        
        try:
            with Image.open(file_path) as img:
                width, height = img.size
                characteristics["width"] = width
                characteristics["height"] = height
                # Формат файла и поддержка EXIF (PNG/GIF не хранят EXIF как JPEG)
                fmt = (img.format or "").upper()
                characteristics["file_format"] = fmt or None
                characteristics["supports_exif"] = fmt not in ("PNG", "GIF", "BMP", "WEBP")
                
                # Соотношение сторон
                if height > 0:
                    aspect_ratio = width / height
                    characteristics["aspect_ratio"] = round(aspect_ratio, 2)
                    
                    # Квадратное изображение - частый признак ИИ
                    if abs(aspect_ratio - 1.0) < 0.01:
                        characteristics["is_square"] = True
                        characteristics["suspicious_features"].append("Квадратное изображение (типично для ИИ)")
                
                # Стандартные размеры для ИИ-генераторов
                standard_ai_sizes = [
                    (512, 512), (768, 768), (1024, 1024), (512, 768), (768, 512),
                    (1024, 1024), (1152, 896), (896, 1152), (1344, 768), (768, 1344),
                    (1536, 640), (640, 1536), (1024, 1792), (1792, 1024)
                ]
                
                if (width, height) in standard_ai_sizes or (height, width) in standard_ai_sizes:
                    characteristics["is_standard_ai_size"] = True
                    characteristics["suspicious_features"].append(f"Стандартный размер ИИ-генератора: {width}x{height}")
                
                # Проверка наличия GPS
                if 'gps' in exif_data:
                    characteristics["has_gps"] = True
                
                # Проверка наличия информации о камере
                if 'camera_make' in exif_data or 'camera_model' in exif_data:
                    characteristics["has_camera_info"] = True
                
                # Проверка параметров съемки
                shooting_params = ['iso', 'exposure_time', 'f_number', 'focal_length']
                if any(param in exif_data for param in shooting_params):
                    characteristics["has_shooting_params"] = True
        
        except Exception as e:
            characteristics["error"] = str(e)
        
        return characteristics
    
    def check_metadata_integrity(self, exif_data: Dict, xmp_data: Dict, image_chars: Dict) -> Dict[str, Any]:
        """Проверка целостности метаданных"""
        integrity = {
            "has_exif": len(exif_data) > 0 and 'error' not in exif_data,
            "has_xmp": len(xmp_data) > 0 and 'error' not in xmp_data,
            "metadata_removed": False,
            "contradictions": []
        }
        
        # Проверка на удаление метаданных
        # Если изображение высокого качества, но нет EXIF - подозрительно
        if not integrity["has_exif"] and not integrity["has_xmp"]:
            integrity["metadata_removed"] = True
        
        # Дополнительная проверка: если изображение выглядит как фото, но нет метаданных
        if image_chars.get("width") and image_chars.get("height"):
            width = image_chars["width"]
            height = image_chars["height"]
            # Высокое разрешение без метаданных - подозрительно
            if width >= 1024 and height >= 1024 and not integrity["has_exif"]:
                integrity["contradictions"].append("Высокое разрешение без метаданных")
        
        # Проверка противоречий
        if integrity["has_exif"]:
            # Проверка на несоответствие даты и времени
            if 'date_time' in exif_data:
                # Можно добавить проверку на разумность даты
                pass
        
        return integrity
    
    def detect_ai_software(self, exif_data: Dict, xmp_data: Dict) -> List[str]:
        """Поиск упоминаний ИИ-инструментов в метаданных"""
        detected = []
        
        # Проверка C2PA метаданных (самый надежный способ детекции ИИ!)
        if '_c2pa_metadata' in exif_data:
            c2pa = exif_data['_c2pa_metadata']
            
            # Software Agent Name (GPT-4o, DALL-E и т.д.)
            if 'c2pa_software_agent' in c2pa:
                agent = str(c2pa['c2pa_software_agent'])
                detected.append(f"C2PA: {agent}")
            
            # Generator Name (ChatGPT, DALL-E и т.д.)
            if 'c2pa_generator_name' in c2pa:
                generator = str(c2pa['c2pa_generator_name'])
                detected.append(f"C2PA Generator: {generator}")
            
            # Digital Source Type указывает на алгоритмический источник
            if 'c2pa_digital_source_type' in c2pa:
                source_type = str(c2pa['c2pa_digital_source_type'])
                if 'trainedAlgorithmicMedia' in source_type or 'algorithmic' in source_type.lower():
                    detected.append("C2PA: Trained Algorithmic Media (ИИ-контент)")
        
        # C2PA индикаторы из конвертации
        if '_c2pa_indicators' in exif_data:
            detected.extend(exif_data['_c2pa_indicators'])
        
        # Поиск в EXIF Software
        if 'software' in exif_data:
            software_lower = exif_data['software'].lower()
            for keyword in self.ai_software_keywords:
                if keyword.lower() in software_lower:
                    # Сохраняем оригинальное значение, но также добавляем найденный ключ
                    if exif_data['software'] not in detected:
                        detected.append(exif_data['software'])
                    # Добавляем найденный ключ для более точной идентификации
                    if keyword not in detected:
                        detected.append(keyword.title())
        
        # Поиск в XMP данных (более тщательный поиск)
        if 'raw_xmp' in xmp_data:
            xmp_str = str(xmp_data['raw_xmp']).lower()
            for keyword in self.ai_software_keywords:
                if keyword.lower() in xmp_str:
                    if keyword.title() not in detected:
                        detected.append(keyword.title())
        
        # Поиск в других полях EXIF
        for key, value in exif_data.items():
            if isinstance(value, str):
                value_lower = value.lower()
                # Проверяем на C2PA поля
                if 'c2pa' in key.lower() or 'cbor' in key.lower():
                    if any(kw in value_lower for kw in ['gpt', 'chatgpt', 'dall', 'midjourney', 'stable diffusion']):
                        detected.append(f"Найдено в {key}: {value}")
                
                # Общий поиск по ключевым словам
                for keyword in self.ai_software_keywords:
                    if keyword.lower() in value_lower:
                        if keyword.title() not in detected:
                            detected.append(keyword.title())
        
        return list(set(detected))  # Удаление дубликатов
    
    def _convert_to_degrees(self, value) -> float:
        """Конвертация GPS координат в градусы"""
        d = float(value.values[0].num) / float(value.values[0].den)
        m = float(value.values[1].num) / float(value.values[1].den)
        s = float(value.values[2].num) / float(value.values[2].den)
        return d + (m / 60.0) + (s / 3600.0)
